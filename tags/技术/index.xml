<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技术 on CocaColf</title><link>https://cocacolf.github.io/tags/%E6%8A%80%E6%9C%AF/</link><description>Recent content in 技术 on CocaColf</description><generator>Hugo -- gohugo.io</generator><copyright>&amp;copy; 2020 CocaColf</copyright><lastBuildDate>Thu, 14 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cocacolf.github.io/tags/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>vue-router重复点击报错和新链接跳转失败</title><link>https://cocacolf.github.io/blog/vue-router-issues/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://cocacolf.github.io/blog/vue-router-issues/</guid><description>最近解决了项目的前端路由问题，具体而言有两个：
路由重复点击，会在控制台输出报错 一个 vue-router 渲染出来的 a 标签，右键新链接打开，在新页面无法打开网页 由于我们公司内外网隔离，所以无法具体截图现象。
路由重复点击，会在控制台输出报错 报错的大概内容为： vueAll.js?v=3.0:2 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: xxxx。
阅读 vue-router 的文档，可以看到：
router.push 或 router.replace 将返回一个 Promise
查看 vue-router 源码，从源码此处可以看出，我们对此方法进行异常处理，便可一劳永逸解决此问题。
因此在初始化路由时，对此方法进行处理：
import VueRouter from &amp;#39;vue-router&amp;#39;; function handleRouterErr (methodsList) { methodsList.forEach(item =&amp;gt; { const ORIGIN_METHOD = VueRouter.prototype[item]; VueRouter.prototype[item] = function (location) { let vm = this; return ORIGIN_METHOD.call(vm, location).catch(err =&amp;gt; err); } }); } // 调用 handleRouterErr([&amp;#39;push&amp;#39;, &amp;#39;replace&amp;#39;]) 无法在新标签页打开链接 右键一个 vue-router 渲染的 a 标签，新标签页打开后页面显示 Not Found。</description></item><item><title>简单版html模板引擎</title><link>https://cocacolf.github.io/blog/%E7%AE%80%E5%8D%95%E7%89%88html%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</link><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><guid>https://cocacolf.github.io/blog/%E7%AE%80%E5%8D%95%E7%89%88html%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</guid><description>背景 功能中包含一个历史申请记录的显示页面，简笔画简单画了一下，如下所示：
不知道多久没写过字了，画下来的东西着实丑，既然不能绘色，那就绘声一下。 每一条记录对应一个面板，每一个面板上呈现着对应记录的信息。那么不同的审批状态，就有很多东西不一样：
数据，这个没得说 内容的样式。比如审批成功用绿色标识，失败是红色 操作。比如审批中，那么就有一个撤销申请的按钮；其他的状态，就没有这个按钮，但是有一个面板折叠的按钮 面板左侧有状态条，反映当前的状态，同时也是时间线的作用 。。。 这个历史申请的数据是用XML格式传递的，如下所示：
&amp;lt;?xml version=\&amp;#34;1.0\&amp;#34; encoding=\&amp;#34;utf-8\&amp;#34;?&amp;gt; &amp;lt;Expansion&amp;gt; &amp;lt;Result&amp;gt;0&amp;lt;/Result&amp;gt; &amp;lt;ApplicationRecord&amp;gt; &amp;lt;record id=&amp;#34;1&amp;#34; status=&amp;#34;0&amp;#34; apply_cpu=&amp;#34;4&amp;#34; apply_mem=&amp;#34;8&amp;#34; apply_disk=&amp;#34;256&amp;#34; apply_time=&amp;#34;2019-10-14 20:00&amp;#34; approve_time=&amp;#34;2019-10-15 15:00&amp;#34; apply_reason=&amp;#34;卡得不能用了&amp;#34; approve_reason=&amp;#34;满足你&amp;#34; admin_name=&amp;#34;XXX&amp;#34; admin_phone=&amp;#34;2333333&amp;#34; admin_email=&amp;#34;test@gmail.com&amp;#34;/&amp;gt; &amp;lt;record id=&amp;#34;2&amp;#34; status=&amp;#34;2&amp;#34; apply_cpu=&amp;#34;4&amp;#34; apply_mem=&amp;#34;8&amp;#34; apply_disk=&amp;#34;256&amp;#34; apply_time=&amp;#34;2019-10-14 20:00&amp;#34; approve_time=&amp;#34;2019-10-15 15:00&amp;#34; apply_reason=&amp;#34;卡得不能用了&amp;#34; approve_reason=&amp;#34;那就继续卡着吧&amp;#34; admin_name=&amp;#34;XXX&amp;#34; admin_phone=&amp;#34;2333333&amp;#34; admin_email=&amp;#34;test@gmail.com&amp;#34;/&amp;gt; &amp;lt;/ApplicationRecord&amp;gt; &amp;lt;/Expansion&amp;gt; 所以很明显，要去遍历解析这个XML，去循环创建面板，再根据每条记录里对应的字段，写上正确的内容以及设置不同的样式。
由于某些原因，没有使用任何样式库或者框架，使用原生js编写。
以上是背景。
思路 当然这个需求没有难点，最一般的方法，当然就是html字符串拼接，在大量的 js if else逻辑里，将不同的数据和html片段拼接起来。其中一个片段可能是这样：
var data = {}; // 数据 var str = &amp;#39;&amp;#39;; // html拼接 if(data.</description></item><item><title>组内Node.js分享</title><link>https://cocacolf.github.io/blog/%E7%BB%84%E5%86%85node.js%E5%88%86%E4%BA%AB/</link><pubDate>Thu, 22 Aug 2019 00:00:00 +0000</pubDate><guid>https://cocacolf.github.io/blog/%E7%BB%84%E5%86%85node.js%E5%88%86%E4%BA%AB/</guid><description>昨天得知今天要进行小组分享，但是我内心并不慌张。关于今天的分享“当我在学习Node时，我在学什么”，是自己一路学习的心得体会，即便临场讲述也能言之有物。
聊什么  其实在两周前，我报名分享时，我打算自下而上来分享Node，从底层架构到上层应用，但后来我可以很明显的预知到这样分享的效果会不好。所以我改变了分享的内容，同时由于时间原因，这次分享侧重点并不是在讲述Node是什么，以及Node Api相关的东西，我也相信以大家的自学能力，入门并不是问题。我今天分享的是个人在初期学习Node的过程中的经历、感受。
说说历史  我喜欢听故事也喜欢讲故事，所以我还是想从最开始说起。那是2009年，Ryan Dahl想写一个基于事件驱动和非阻塞IO的高性能服务器，他尝试了许多语言来构建，比如C、Lua、Haskell等，但由于自己hold不住或语言本身已存在这些东西，他最后瞄向了没有历史包袱的Javascript，从而创建了Node。但要注意的是，Node并不是一门语言，只是一个Javascript的运行时，可以理解为PythonVM之于Python，JVM之于Java。
特点  异步IO和基于事件和回调函数。比如在Node中使用文件模块读取文件:
fs.readFile(&amp;#39;./1.txt&amp;#39;, (err, data) =&amp;gt; { console.log(data); }); fs.readFile(&amp;#39;./2.txt&amp;#39;, (err, data) =&amp;gt; { console.log(data); }); 对于这种风格显然我们不陌生，比如：
oneDom.addEventListener(&amp;#39;click&amp;#39;, function() { // do something }); $.get(&amp;#39;/url&amp;#39;, function(data) =&amp;gt; { // do something }) 这种异步IO，带来的好处就是性能更快，它的耗时取决于最慢的操作，但是也带来了成本，一是异步风格带来的理解成本，因为编码顺序和执行顺序并不一致；二是错误的处理。
另外，我们可以看到代码风格是基于事件和回调函数风格，再举一个例子，使用原生http模块来接收post数据时：
let str = &amp;#39;&amp;#39;; req.on(&amp;#39;data&amp;#39;, (trunk) =&amp;gt; { str += trunk; }); req.on(&amp;#39;end&amp;#39;, () =&amp;gt; { res.end(str); }); 这种基于事件的回调风格可以有一些优点，也是我个人最喜欢Node的地方，Don't Call Me, I Wll Call You。这种风格可以带来轻解耦，我们只需要关注事务即可。但是也有一些不足，比如每个事件事务相对独立，如果事件之间要彼此协作就不太方便。</description></item><item><title>Node.js Event Loop</title><link>https://cocacolf.github.io/blog/node.js-event-loop/</link><pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate><guid>https://cocacolf.github.io/blog/node.js-event-loop/</guid><description>第一次接触Node的时候就喜欢上它了，但是那时候学习它的时候，一直感觉入不了门，会写一点但总感觉隔了层膜，挺难受的，后来的渐渐有所感觉是在简单的了解了事件驱动后。再后来就觉得JS层面的Node其实没有太多的东西，于是开始想要去了解下层一点的东西。最近看了一篇非常好的博文，在这里做几点记录。
什么是事件循环 event Demultiplexer来处理事件分发，同时把IO操作委托给硬件。它是一种抽象，各操作系统有自己的实现(Linux -&amp;gt; epoll,MacOS -&amp;gt; kqueue,Windows -&amp;gt; IOCP)。为了支持不同的操作系统中不同的IO操作，于是诞生了libuv。
当IO操作被处理时，相对应的回调函数就被加入事件队列
事件队列执行并清空事件队列
循环上述过程
事件队列 简化的事件循环的执行阶段顺序
 这里有几个要点:
有两个中间过渡检查: process.nextTick 和 process.resolve，且前者优先级大于后者
next tick 队列始终不为空导致IO饿死的问题
Timers并不一定会准确执行，与CPU性能和当前所处的事件阶段有关
两个很经典的例子
// 执行顺序不能保证 setTimeout(function() { console.log(&amp;#39;setTimeout&amp;#39;); }, 0); setImmediate(function() { console.log(&amp;#39;setImmediate&amp;#39;); }); // setImmediate 一定在 setTimeout 之前执行 const fs = require(&amp;#39;fs&amp;#39;); fs.readFile(__filename, () =&amp;gt; { setTimeout(() =&amp;gt; { console.</description></item></channel></rss>