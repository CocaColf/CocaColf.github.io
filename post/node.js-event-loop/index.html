<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Node.js Event Loop - 庭前桃李满，院外小径芳</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="CocaColf"><meta name=description content="第一次接触Node的时候就喜欢上它了，但是那时候学习它的时候，一直感觉入不了门，会写一点但总感觉隔了层膜，挺难受的，后来的渐渐有所感觉是在简"><meta name=generator content="Hugo 0.78.1"><link rel=canonical href=http://CocaColf.github.io/post/node.js-event-loop/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.f1e506a781bf25d33ffc18aa6b4e972a965c58049d27d4f92b7db2e9bf28e4bf.css integrity="sha256-8eUGp4G/JdM//Biqa06XKpZcWASdJ9T5K32y6b8o5L8=" media=screen crossorigin=anonymous><meta property="og:title" content="Node.js Event Loop"><meta property="og:description" content="第一次接触Node的时候就喜欢上它了，但是那时候学习它的时候，一直感觉入不了门，会写一点但总感觉隔了层膜，挺难受的，后来的渐渐有所感觉是在简"><meta property="og:type" content="article"><meta property="og:url" content="http://CocaColf.github.io/post/node.js-event-loop/"><meta property="article:published_time" content="2019-04-28T00:00:00+00:00"><meta property="article:modified_time" content="2019-04-28T00:00:00+00:00"><meta itemprop=name content="Node.js Event Loop"><meta itemprop=description content="第一次接触Node的时候就喜欢上它了，但是那时候学习它的时候，一直感觉入不了门，会写一点但总感觉隔了层膜，挺难受的，后来的渐渐有所感觉是在简"><meta itemprop=datePublished content="2019-04-28T00:00:00+00:00"><meta itemprop=dateModified content="2019-04-28T00:00:00+00:00"><meta itemprop=wordCount content="2635"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Node.js Event Loop"><meta name=twitter:description content="第一次接触Node的时候就喜欢上它了，但是那时候学习它的时候，一直感觉入不了门，会写一点但总感觉隔了层膜，挺难受的，后来的渐渐有所感觉是在简"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>庭前桃李满，院外小径芳</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=http://CocaColf.github.io/>首页</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://CocaColf.github.io/post/>归档</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://CocaColf.github.io/categories/>分类</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://CocaColf.github.io/about/>关于</a></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class="header container"><div class=logo-wrapper><a href=/ class=logo>庭前桃李满，院外小径芳</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=http://CocaColf.github.io/>首页</a></li><li class=menu-item><a class=menu-item-link href=http://CocaColf.github.io/post/>归档</a></li><li class=menu-item><a class=menu-item-link href=http://CocaColf.github.io/categories/>分类</a></li><li class=menu-item><a class=menu-item-link href=http://CocaColf.github.io/about/>关于</a></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight"><div class=content-wrapper><div id=content class="content container"><article class="post bg-white"><header class=post-header><h1 class=post-title>Node.js Event Loop</h1><div class=post-meta><time datetime=2019-04-28 class=post-time>2019-12-09</time><div class=post-category><a href=http://CocaColf.github.io/categories/%E6%8A%80%E6%9C%AF/>技术</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#什么是事件循环>什么是事件循环</a></li><li><a href=#事件队列>事件队列</a></li></ul></nav></div></div><div class=post-content><p>    第一次接触Node的时候就喜欢上它了，但是那时候学习它的时候，一直感觉入不了门，会写一点但总感觉隔了层膜，挺难受的，后来的渐渐有所感觉是在简单的了解了事件驱动后。再后来就觉得JS层面的Node其实没有太多的东西，于是开始想要去了解下层一点的东西。最近看了一篇非常好的<a href=https://github.com/zhangxiang958/zhangxiang958.github.io/issues/43>博文</a>，在这里做几点记录。</p><h2 id=什么是事件循环>什么是事件循环</h2><p><img src=https://camo.githubusercontent.com/dd28ae6f0212f319720e8f712d8db15ff8feffc6/687474703a2f2f696d672e696a61727669732e636e2f76322d36363934636163633138343964386336313438333831616161643165616637375f68642e6a7067 alt=事件轮询></p><ul><li><p><code>event Demultiplexer</code>来处理事件分发，同时把IO操作委托给硬件。它是一种抽象，各操作系统有自己的实现(Linux -> epoll,MacOS -> kqueue,Windows -> IOCP)。为了支持不同的操作系统中不同的IO操作，于是诞生了libuv。</p></li><li><p>当IO操作被处理时，相对应的回调函数就被加入事件队列</p></li><li><p>事件队列执行并清空事件队列</p></li><li><p>循环上述过程</p></li></ul><h2 id=事件队列>事件队列</h2><p><strong>简化的事件循环的执行阶段顺序</strong></p><p><img src=https://camo.githubusercontent.com/d94dd80a874eca894c6b9fb7e7ef643f84977835/687474703a2f2f696d672e696a61727669732e636e2f76322d34386333386431663231663438306462363131643962303138323864303762615f722e6a7067 alt=事件队列的执行顺序></p><p>    这里有几个要点:</p><ul><li><p>有两个中间过渡检查: <code>process.nextTick</code> 和 <code>process.resolve</code>，且前者优先级大于后者</p></li><li><p>next tick 队列始终不为空导致IO饿死的问题</p></li><li><p><code>Timers</code>并不一定会准确执行，与CPU性能和当前所处的事件阶段有关</p></li><li><p>两个很经典的例子</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-js data-lang=js><span class=c1>// 执行顺序不能保证
</span><span class=c1></span><span class=nx>setTimeout</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;setTimeout&#39;</span><span class=p>);</span>
<span class=p>},</span> <span class=mi>0</span><span class=p>);</span>
<span class=nx>setImmediate</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;setImmediate&#39;</span><span class=p>);</span>
<span class=p>});</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-js data-lang=js><span class=c1>// setImmediate 一定在 setTimeout 之前执行
</span><span class=c1></span><span class=kr>const</span> <span class=nx>fs</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;fs&#39;</span><span class=p>);</span>

<span class=nx>fs</span><span class=p>.</span><span class=nx>readFile</span><span class=p>(</span><span class=nx>__filename</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;timeout&#39;</span><span class=p>);</span>
    <span class=p>},</span> <span class=mi>0</span><span class=p>);</span>
    <span class=nx>setImmediate</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;immediate&#39;</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>});</span>
</code></pre></td></tr></table></div></div><p><strong>事件循环的阶段</strong></p><p>当Node.js启动时会初始化event loop, 每一个event loop都会包含按如下顺序循环阶段：</p><p><img src=https://user-gold-cdn.xitu.io/2018/8/2/164f6645917f6cce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt=事件循环阶段></p><ul><li><p>Timer ——到期的定时器回调和 interval 回调。</p></li><li><p>Pending IO Callback——处理被挂起的 I/O 事件，包括完成的和失败的。</p></li><li><p>Idle —— 执行一些 libuv 内部操作。</p></li><li><p>Prepare —— 执行一些 I/O 操作的预准备工作。</p></li><li><p>Poll —— <code>可选择性地</code>等待 I/O 操作完成，<code>这里可能会发生Node阻塞</code>。在node.js里，任何异步方法（除timer,close,setImmediate之外）完成时，都会将其callback加到poll queue里,并立即执行。所以Poll阶段：<code>1.处理poll队列（poll quenue）的事件(callback); 2.当到达timers指定的时间时,执行timers的callback;</code>
这里引用博客上的一段解释:</p></li></ul><blockquote><p>如果event loop进入了 poll阶段，且代码未设定timer，将会发生下面情况：</p><ul><li>如果poll queue不为空，event loop将同步的执行queue里的callback,直至queue为空，或执行的callback到达系统上限;</li></ul></blockquote><blockquote><p>如果poll queue为空，将会发生下面情况：</p><ul><li>如果代码已经被setImmediate()设定了callback, event loop将结束poll阶段进入check阶段，并执行check阶段的queue (check阶段的queue是 setImmediate设定的)</li></ul></blockquote><blockquote><p>如果代码没有设定setImmediate(callback)，event loop将阻塞在该阶段等待callbacks加入poll queue;</p></blockquote><blockquote><p>如果event loop进入了 poll阶段，且代码设定了timer：</p><ul><li>如果poll queue进入空状态时（即poll 阶段为空闲状态），event loop将检查timers,如果有1个或多个timers时间时间已经到达，event loop将按循环顺序进入 timers 阶段，并执行timer queue.</li></ul></blockquote><pre><code>关于这里，我觉得 cNode上这个 [帖子](https://cnodejs.org/topic/57d68794cb6f605d360105bf) 的讨论非常精彩。
</code></pre><ul><li><p>Check handlers —— 执行一些 I/O 操作的后续处理工作，通常来说，setImmediate 添加的回调也会在这个阶段执行。</p></li><li><p>Close handlers —— 执行一些 close 事件相关的操作比如 socket 连接等等。</p></li><li><p>此外，process.nextTick()不在event loop的任何阶段执行，而是在各个阶段切换的中间执行
<strong>事件轮询的核心代码</strong></p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=c1>//deps/uv/src/unix/core.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>uv_run</span><span class=p>(</span><span class=n>uv_loop_t</span> <span class=o>*</span><span class=n>loop</span><span class=p>,</span> <span class=n>uv_run_mode</span> <span class=n>mode</span><span class=p>)</span> <span class=p>{</span>
	<span class=kt>int</span> <span class=n>timeout</span><span class=p>;</span>
	<span class=kt>int</span> <span class=n>r</span><span class=p>;</span>
	<span class=kt>int</span> <span class=n>ran_pending</span><span class=p>;</span>
	<span class=c1>//uv__loop_alive返回的是event loop中是否还有待处理的handle或者request
</span><span class=c1></span>	<span class=c1>//以及closing_handles是否为NULL,如果均没有,则返回0
</span><span class=c1></span>	<span class=n>r</span> <span class=o>=</span> <span class=n>uv__loop_alive</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
	<span class=c1>//更新当前event loop的时间戳,单位是ms
</span><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>r</span><span class=p>)</span>
    	<span class=n>uv__update_time</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
	<span class=k>while</span> <span class=p>(</span><span class=n>r</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>loop</span><span class=o>-&gt;</span><span class=n>stop_flag</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    	<span class=c1>//使用Linux下的高精度Timer hrtime更新loop-&gt;time,即event loop的时间戳
</span><span class=c1></span>    	<span class=n>uv__update_time</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
    	<span class=c1>//执行判断当前loop-&gt;time下有无到期的Timer,显然在同一个loop里面timer拥有最高的优先级
</span><span class=c1></span>    	<span class=n>uv__run_timers</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
    	<span class=c1>//判断当前的pending_queue是否有事件待处理,并且一次将&amp;loop-&gt;pending_queue中的uv__io_t对应的cb全部拿出来执行
</span><span class=c1></span>    	<span class=n>ran_pending</span> <span class=o>=</span> <span class=n>uv__run_pending</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
    	<span class=c1>//实现在loop-watcher.c文件中,一次将&amp;loop-&gt;idle_handles中的idle_cd全部执行完毕(如果存在的话)
</span><span class=c1></span>    	<span class=n>uv__run_idle</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
    	<span class=c1>//实现在loop-watcher.c文件中,一次将&amp;loop-&gt;prepare_handles中的prepare_cb全部执行完毕(如果存在的话)
</span><span class=c1></span>    	<span class=n>uv__run_prepare</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>

    	<span class=n>timeout</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    	<span class=c1>//如果是UV_RUN_ONCE的模式,并且pending_queue队列为空,或者采用UV_RUN_DEFAULT(在一个loop中处理所有事件),则将timeout参数置为
</span><span class=c1></span>    	<span class=c1>//最近的一个定时器的超时时间,防止在uv_io_poll中阻塞住无法进入超时的timer中
</span><span class=c1></span>    	<span class=k>if</span> <span class=p>((</span><span class=n>mode</span> <span class=o>==</span> <span class=n>UV_RUN_ONCE</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>ran_pending</span><span class=p>)</span> <span class=o>||</span> <span class=n>mode</span> <span class=o>==</span> <span class=n>UV_RUN_DEFAULT</span><span class=p>)</span>
        	<span class=n>timeout</span> <span class=o>=</span> <span class=n>uv_backend_timeout</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
    	<span class=c1>//进入I/O处理的函数(重点分析的部分),此处挂载timeout是为了防止在uv_io_poll中陷入阻塞无法执行timers;并且对于mode为
</span><span class=c1></span>    	<span class=c1>//UV_RUN_NOWAIT类型的uv_run执行,timeout为0可以保证其立即跳出uv__io_poll,达到了非阻塞调用的效果
</span><span class=c1></span>    	<span class=n>uv__io_poll</span><span class=p>(</span><span class=n>loop</span><span class=p>,</span> <span class=n>timeout</span><span class=p>);</span>
    	<span class=c1>//实现在loop-watcher.c文件中,一次将&amp;loop-&gt;check_handles中的check_cb全部执行完毕(如果存在的话)
</span><span class=c1></span>    	<span class=n>uv__run_check</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
    	<span class=c1>//执行结束时的资源释放,loop-&gt;closing_handles指针指向NULL
</span><span class=c1></span>    	<span class=n>uv__run_closing_handles</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>

    	<span class=k>if</span> <span class=p>(</span><span class=n>mode</span> <span class=o>==</span> <span class=n>UV_RUN_ONCE</span><span class=p>)</span> <span class=p>{</span>
        	<span class=c1>//如果是UV_RUN_ONCE模式,继续更新当前event loop的时间戳
</span><span class=c1></span>        	<span class=n>uv__update_time</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
        	<span class=c1>//执行timers,判断是否有已经到期的timer
</span><span class=c1></span>        	<span class=n>uv__run_timers</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
    	<span class=p>}</span>
    	<span class=n>r</span> <span class=o>=</span> <span class=n>uv__loop_alive</span><span class=p>(</span><span class=n>loop</span><span class=p>);</span>
    	<span class=c1>//在UV_RUN_ONCE和UV_RUN_NOWAIT模式中,跳出当前的循环
</span><span class=c1></span>    	<span class=k>if</span> <span class=p>(</span><span class=n>mode</span> <span class=o>==</span> <span class=n>UV_RUN_ONCE</span> <span class=o>||</span> <span class=n>mode</span> <span class=o>==</span> <span class=n>UV_RUN_NOWAIT</span><span class=p>)</span>
        	<span class=k>break</span><span class=p>;</span>
		<span class=p>}</span>
		
	<span class=c1>//标记当前的stop_flag为0,表示当前的loop执行完毕
</span><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>loop</span><span class=o>-&gt;</span><span class=n>stop_flag</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
    	<span class=n>loop</span><span class=o>-&gt;</span><span class=n>stop_flag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
	<span class=c1>//返回r的值
</span><span class=c1></span>	<span class=k>return</span> <span class=n>r</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>CocaColf</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2019-12-09</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%B8%80%E6%AC%A1%E8%82%A0%E9%95%9C%E6%A3%80%E6%9F%A5/><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg></i><span class="prev-text nav-default">进行了一次肠镜检查</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/><span class="next-text nav-default">什么才算是真正的编程能力</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"/></svg></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=icon-links><a href=CocaColf@gmail.com rel="me noopener" class=iconfont title=email target=_blank><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408 1361.641813S1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523L83.726336 1024H682.532949 753.579947 1348.948139L1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955C777.248 802.205449 742.347691 811.03081 718.063616 811.603883z"/></svg></a><a href=https://github.com/CocaColf rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg></a><a href=http://CocaColf.github.io/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a></span>
<span class=copyright-year>&copy;
2020
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg></i></span><span class=author>CocaColf</span></span></div></footer><div class=back-to-top id=back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script><script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script><script type=text/javascript src=/js/load-photoswipe.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>