<!doctype html><html lang=en-us><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?9fb3cda71a61f7006356f0c75fac487d";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>开发了设计稿规范检视工具 - CocaColf</title><meta property="og:title" content="开发了设计稿规范检视工具 - CocaColf"><meta name=twitter:card content="summary"><meta property="description" content="规范的设计稿对 D2C（设计稿生成代码）是非常重要的，如果存在许多层级错乱的节点、冗余的节点、交叉的节点，那么势必在 D2C 开发的过程中需要处理许多的异常节点的处理和计算，有很多异常场景很难通过代码的手段去解决，从而很难生成正确的高可用性的前端代码。因此 D2C 的实践过程中需要提炼出许多 D2C 的设计规范让设计师配合。
同时，设计团队也有自己的设计规范，在设计师的日常设计中需要进行设计检视， &amp;hellip;"><meta property="og:description" content="规范的设计稿对 D2C（设计稿生成代码）是非常重要的，如果存在许多层级错乱的节点、冗余的节点、交叉的节点，那么势必在 D2C 开发的过程中需要处理许多的异常节点的处理和计算，有很多异常场景很难通过代码的手段去解决，从而很难生成正确的高可用性的前端代码。因此 D2C 的实践过程中需要提炼出许多 D2C 的设计规范让设计师配合。
同时，设计团队也有自己的设计规范，在设计师的日常设计中需要进行设计检视， &amp;hellip;"><meta name=twitter:image content="https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/%E6%A3%80%E8%A7%86%E6%8F%92%E4%BB%B6.png"><link href=//cdn.bootcss.com/highlight.js/9.12.0/styles/monokai.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body class=blog><header class=masthead><h1><a href=/>CocaColf</a></h1><p class=tagline>庭前桃李满，院外小径芳</p><nav class=menu><input id=menu-check type=checkbox hidden>
<label id=menu-label for=menu-check class=unselectable hidden><span class="icon close-icon">✕</span>
<span class="icon open-icon">☰</span>
<span class=text>Menu</span></label><ul><li><a href=/tags/writing/>文字</a></li><li><a href=/tags/technical/>技术</a></li><li><a href=/about/>关于</a></li><li><a href=/tags/>标签</a></li><li><a href=/index.xml>订阅</a></li></ul></nav></header><article class=main><header class=title><h1>开发了设计稿规范检视工具</h1><h3>2023-12-26</h3><hr></header><h1 id=背景>背景</h1><p>规范的设计稿对 D2C（设计稿生成代码）是非常重要的，如果存在许多层级错乱的节点、冗余的节点、交叉的节点，那么势必在 D2C 开发的过程中需要处理许多的异常节点的处理和计算，有很多异常场景很难通过代码的手段去解决，从而很难生成正确的高可用性的前端代码。因此 D2C 的实践过程中需要提炼出许多 D2C 的设计规范让设计师配合。</p><p>同时，设计团队也有自己的设计规范，在设计师的日常设计中需要进行设计检视，类似于我们开发人员的 code review。间距、颜色等一一核对的检视是枯燥的。</p><p>如果有个工具可以让设计师在设计自检或设计评审时一键检视存在的设计问题，那么无论对于设计稿的质量或者是设计效率都有很大的帮助。设计稿检视工具的需求应运而生。它就像是设计稿的 ESLint。</p><p>很显然，由于两种不同角色对规范的不同要求，因此设计稿检视工具的规则会分为 D2C 规则和设计规则两种类型。</p><h1 id=整体效果>整体效果</h1><p><strong>选中设计稿，使用设计稿检视插件一键检测</strong></p><p><img src=https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/%E6%A3%80%E8%A7%86%E6%8F%92%E4%BB%B6.png alt=插件></p><p><strong>检测完成自动打开检测报告</strong></p><p>检测报告以画板的形式展示（和设计软件一致的操作方式），在这里可以进行问题查看、问题忽略、问题过滤等操作，同一个设计稿被忽略的问题在下一次检视时将不会提示：</p><p><img src=https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/%E6%A3%80%E8%A7%86%E7%BB%93%E6%9E%9C.png alt=检测结果></p><p><strong>历史记录和数据汇总</strong></p><p>所有的检视记录会按照「同一个版本」，「同一个设计稿」的维度进行聚合，同时会对这些记录进行数据分析和汇总：</p><p><img src=https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95.png alt=历史记录></p><h1 id=实现整体流程>实现：整体流程</h1><p><img src=https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%95%B4%E4%BD%93.png alt=整体流程></p><p><strong>插件端</strong></p><p>用户在 Mastergo 设计稿页面上选中需要检视的设计稿后点击插件开始检测，插件会对设计稿进行节点提取（节点树）、图片导出等设计稿数据处理，将数据发送给服务端</p><p><strong>服务端</strong></p><p>服务端收到检视任务后，主要做几件事：</p><ul><li>对上报的设计稿数据做进一步必要的处理，比如将插件上报的图片 (base 64)转为静态资源存储，用于 AI 识别</li><li>将检视任务加入任务队列中，在任务队列中会对设计稿进行 AI 组件识别，得到组件识别结果。将这个和原始设计稿信息一起提供给「规范检测库」进行检视，获得检视结果</li><li>搜索相同的设计稿的历史记录，将这个设计稿以前处置（如某个问题被忽略）延续到本次检视操作；同时将相同的设计稿的检视结果进行合并</li></ul><p>组件识别结果：</p><p><img src=https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%E7%BB%84%E4%BB%B6%E8%AF%86%E5%88%AB%E7%BB%93%E6%9E%9C.png alt=组件识别结果></p><p><strong>UI 平台</strong></p><p>提供报告展示、问题处置、历史记录、管理员操作等功能。</p><p>整体流程就是普通的 web 开发，毫无疑问最核心的功能和能力在于「规范检测库」。</p><h1 id=实现规范检测库>实现：规范检测库</h1><p><img src=https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%E5%BA%93%E6%B5%81%E7%A8%8B.png alt=规范检测库></p><h3 id=输入数据>输入数据</h3><p>我们需要检测的对象按照场景划分为两种：设计稿原始节点类型和具体的场景组件。</p><p><strong>设计稿原始节点类型</strong></p><p>比如校验「TEXT 节点」的最小字号、「TEXT 节点」之间不能存在交叉、「子节点」大小不能超过「父容器」的大小。</p><p><strong>具体的场景组件</strong></p><p>表单、表格等具体场景我们是无法从设计稿原始节点中判断出来的，这也是服务端为什么对设计稿进行 AI 组件识别的原因。通过 AI 识别我们知道具体的（场景）组件的位置、大小。</p><p>因此「规范检测库」的输入就是设计稿的原始节点（树）和设计稿组件识别结果。</p><h3 id=上下文环境>上下文环境</h3><p>有些规则需要计算节点之间的关联关系，因此单个规则的输入不仅仅是当前节点。我们可以抽象一个 context 注入到每个规则中去，校验过程中所有规则共享。这种 context 的思想在各种库中非常常见。</p><p>校验过程中需要不断地收集每个规则的校验结果，我们可以在 context 中增加一个 event emitter，规则将问题”广播出去“，然后统一由一个收集者负责接收广播，收集问题。</p><h3 id=策略模式>策略模式</h3><p>如果我们制定了文本规范，那么则会对文本节点进行对应的规则检视。方式则是对输入的数据进行遍历，遇到类型为 TEXT 的节点则进行规则检视；对于表单规范也是同理。用伪代码表示这个过程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>traveAndValidate</span> (<span style=color:#a6e22e>tree</span>, <span style=color:#a6e22e>node</span> =&gt; {
	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;TEXT&#39;</span>) {
		<span style=color:#a6e22e>checkRule1</span>();
		<span style=color:#a6e22e>checkRule2</span>();
	}
	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;xxxx&#39;</span>) {  <span style=color:#75715e>// ...}
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>});
</code></pre></div><p>这样的方式显然是不行的，<code>if-else</code> 多、规则可维护性差、复用性差。这样的场景其实在表单的校验中也很常见，不同的表单有不同的校验规则。对于这种问题策略模式就要派上用场了，下面是使用策略模式制定一个校验器。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 一条规则的定义
</span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Rule</span> {
	<span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>;  <span style=color:#75715e>// 规则名
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>description</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>;  <span style=color:#75715e>// 规则描述
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>level</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;warn&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;error&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;info&#39;</span>;  <span style=color:#75715e>// 报错级别
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>category</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39; D2C&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;design&#39;</span>; <span style=color:#75715e>// 类别
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>checker</span><span style=color:#f92672>:</span> Function;  <span style=color:#75715e>// 规则实现
</span><span style=color:#75715e></span>}
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ComponentValidator</span> {
    <span style=color:#a6e22e>checkerMap</span><span style=color:#f92672>:</span> {[<span style=color:#a6e22e>nodeType</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>[]}  <span style=color:#f92672>=</span> {};  <span style=color:#75715e>// 每个组件绑定的规则
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>strategies</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Record</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>string</span>, <span style=color:#a6e22e>Rule</span><span style=color:#f92672>&gt;</span>;  <span style=color:#75715e>// 策略
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>constructor</span> (<span style=color:#a6e22e>strategies</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Record</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>string</span>, <span style=color:#a6e22e>SubRule</span><span style=color:#f92672>&gt;</span>) {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>strategies</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>strategies</span>;
    }

    <span style=color:#75715e>// 注册不同类型组件的校验规则
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>add</span> (<span style=color:#a6e22e>component</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>, <span style=color:#a6e22e>rules</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>[]) {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>checkerMap</span>[<span style=color:#a6e22e>component</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>rules</span>;
    }

	<span style=color:#75715e>// 遍历节点树，对节点进行规则检查
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>traveAndValidate</span> (<span style=color:#a6e22e>tree</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Tree</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Node</span><span style=color:#f92672>&gt;</span>, <span style=color:#a6e22e>context</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>LintContext</span>) {
        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>component</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tree</span>.<span style=color:#a6e22e>component</span>;

        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>checkerMap</span>[<span style=color:#a6e22e>component</span>]) {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>componentRule</span> <span style=color:#66d9ef>of</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>checkerMap</span>[<span style=color:#a6e22e>component</span>] <span style=color:#f92672>||</span> [])) {
                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>strategies</span>[<span style=color:#a6e22e>componentRule</span>].<span style=color:#a6e22e>checker</span>(<span style=color:#a6e22e>tree</span>, <span style=color:#a6e22e>context</span>);
            }
        }

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>childComponent</span> <span style=color:#66d9ef>of</span> (<span style=color:#a6e22e>tree</span>.<span style=color:#a6e22e>children</span> <span style=color:#f92672>||</span> [])) {
            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>traveAndValidate</span>(<span style=color:#a6e22e>childComponent</span>, <span style=color:#a6e22e>context</span>);
        }
    }

    <span style=color:#a6e22e>start</span> (<span style=color:#a6e22e>context</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>LintContext</span>) {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>traveAndValidate</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>componentTree</span>, <span style=color:#a6e22e>context</span>);
    }
}
</code></pre></div><p>当有了这个校验器后，我们就可以很方便的维护规则了。只需要关注规则的逻辑实现，如果某个组件需要使用某条规则，只需要它需要绑定的规则数组里增加规则名称即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 先制定规则，以及将组件和对应的规则进行映射
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rules</span> <span style=color:#f92672>=</span> {
	<span style=color:#a6e22e>ruleA</span><span style=color:#f92672>:</span> {
		<span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;ruleA&#39;</span>,
	    <span style=color:#a6e22e>description</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;ruleA description&#39;</span>,
	    <span style=color:#a6e22e>level</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;warn&#39;</span>,
	    <span style=color:#a6e22e>category</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;design&#39;</span>,
	    <span style=color:#a6e22e>checker</span> (<span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>context</span>) {  <span style=color:#75715e>// do something }
</span><span style=color:#75715e></span>	},
};
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>registerMap</span> <span style=color:#f92672>=</span> {
	<span style=color:#a6e22e>form</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;ruleA&#39;</span>, <span style=color:#e6db74>&#39;ruleB&#39;</span>],
	<span style=color:#a6e22e>table</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;ruleC&#39;</span>],
	<span style=color:#a6e22e>select</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;ruleD&#39;</span>]
};

<span style=color:#75715e>// 检查所有组件是否符合规范
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>componentChecker</span> (<span style=color:#a6e22e>context</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>LintContext</span>) {
	<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>validator</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ComponentValidator</span>(<span style=color:#a6e22e>rules</span>);
	Object.<span style=color:#a6e22e>entries</span>(<span style=color:#a6e22e>registerMap</span>).<span style=color:#a6e22e>forEach</span>(([<span style=color:#a6e22e>type</span>, <span style=color:#a6e22e>rule</span>]) =&gt; {
		<span style=color:#a6e22e>validator</span>.<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>type</span>, <span style=color:#a6e22e>rule</span>);
	});
	<span style=color:#a6e22e>validator</span>.<span style=color:#a6e22e>start</span>(<span style=color:#a6e22e>context</span>);
}
</code></pre></div><h3 id=规范实现>规范实现</h3><p>规范实现本质上就是按照规则要求进行各种节点之间的关联计算或者是节点的属性检查，在上面 <code>Rule</code> 的定义中可以看到它本质上就是 <code>checker</code> 函数的实现。因为最终问题都是在规则内部使用事件广播的方式由问题收集器统一收集处理，所以对于每个规则内部的实现可自由发挥，只需要最终报告的问题结果的数据结构保持统一。</p><p>规范检测工具的核心在规范检测库，而规范检测库的核心在规范实现。有些规范的实现一点也不简单。比如对于表单，要检查 label 之间是否左对齐、要检查表单的单个一行的各个元素之间的间距，需要提取所有的 label 成组，单行成组等等，要把表单不断地横着分割，竖着切割。横看成岭侧成峰，远近高低各不同。</p><p>此外，这些规则形成的规则库是以插件的形式在「规范检测库」加载的，所以后续不同的设计规范只需关注规则的具体实现即可。</p><h1 id=其他>其他</h1><p>本节为工具的开发或者落地过程中的一些零碎的问题。</p><h2 id=和设计师沟通>和设计师沟通</h2><p>由于使用者是设计师，所以实现工具的过程中需要和设计师进行大量的沟通工作。包括：</p><ul><li>工具的交互实现</li><li>设计规范的提取</li><li>工具的宣贯和推广</li></ul><p>因此需要在设计团队找到一个设计负责人来负责工具的工作。工具的交互实现倒是和平时开发业务差不多，但规范的提取就不那么容易了。因为设计规范虽然看起来是有明文的条条框框的，但是很零碎，要转为工具实现的代码逻辑还有很多的精简、规则定义、报错文案等工作。</p><h2 id=同一个设计稿如何判断>同一个设计稿如何判断</h2><p>无论是下面涉及的「问题忽略」功能，还是「同个设计稿的记录合并」等，都需要能够判断两张设计稿是不是同一个设计稿。</p><p>一个设计稿有两种可能：</p><ul><li>整个设计稿中各个节点编组为一个组合</li><li>设计稿未被编组，是零碎的节点</li></ul><p>第一种场景下，插件上报的设计稿信息中有唯一的 id，所以在 server 我们可以通过这个 id 进行查询即可找到相同设计稿的历史检视记录。</p><p>第二种场景下，没有唯一的 id 存在，那么如何判断设计稿是同一张呢？经过思考，这种情况下一张设计稿本质上是由大量的节点（每个节点有唯一 id）组成的，所以判断是否是同一个设计稿只能通过这个数组来判断，所以我们通过节点 id 数组的相似度（交并比）来判断是否是同一张设计稿。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>/**
</span><span style=color:#75715e> * 使用数组的交并比来判断相似度
</span><span style=color:#75715e> * @param ids 当前被对比的设计稿节点的id
</span><span style=color:#75715e> * @param standardIds 对比的基准
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>isSameDraftByNodeSimilarity</span><span style=color:#f92672>=</span> (<span style=color:#a6e22e>ids</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>[], <span style=color:#a6e22e>standardIds</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>[]) =&gt; {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>iouThread</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.9</span>;

    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>intersection</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ids</span>.<span style=color:#a6e22e>filter</span>(<span style=color:#a6e22e>id</span> =&gt; <span style=color:#a6e22e>standardIds</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#a6e22e>id</span>));
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>union</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Set</span>([...<span style=color:#a6e22e>ids</span>, ...<span style=color:#a6e22e>standardIds</span>]);
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>union</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;

    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>iou</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>intersection</span>.<span style=color:#a6e22e>length</span>) <span style=color:#f92672>/</span> <span style=color:#a6e22e>union</span>.<span style=color:#a6e22e>size</span>;

    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>iou</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>iouThread</span>;
};
</code></pre></div><p>如果这两种情况下都没有找到相同的设计稿，那么就认定为新设计稿。很显然这种策略从逻辑上来看存在一些的问题。举个例子，一个设计稿还未完成时（少量节点）检视和最终完成时检视由于节点的增删可能就会被判断为不同设计稿。不过从现实使用工具的时间来看（最终设计完成准备评审），这个策略是满足要求的。</p><h2 id=忽略问题的实现>忽略问题的实现</h2><p>规则的实现存在 bug 或者 AI 识别存在不准等都可能导致检查出现误报，因此在报告展示界面提供了「问题忽略」操作，本次设计稿检视忽略的问题在下一次检视时将不再提示。</p><p>每一个被报告的问题都会生成一个「问题id」，所以问题忽略就是将被忽略的「问题id」从结果中过滤即可。由于同一个设计稿的判断的问题解决了，那么只要保证同一个节点的同一个问题的「问题id」每次检视都是唯一的即可。那么这个「问题id」的生成是否可以使用<code>[节点 id]-[问题类型]-[问题报错文本]</code>呢？</p><p>理论上同一个节点在每次检查时这些值确实应该是不变的，但是在我的场景中存在一点问题：同一个节点的 id 不一定保持不变。在设计稿中，每个节点都有一个唯一 id，所以设计稿节点中的节点 id 是不变的。但是 AI 识别组件时，每次生成的组件节点都会生成一个不同的 id，所以这导致同一个设计稿在每次 AI 识别时，同一个组件的 id 是不一致的。所以对于组件，必须想一个不变量来替换「节点id」，我选择使用 <code>x-y-width-height</code> 来替代「节点id」，因为理论上只要 AI 识别稳定，同一个设计稿每次同一个区域的识别结果应当是一致的。</p><p>最终使用<code>md5</code>对这些信息进行编码，从而达到同一个节点的同一个问题每次检视都是相同的 id 的目的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>genIssueId</span> (
    <span style=color:#a6e22e>node</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>NodeInfo</span>,
    <span style=color:#a6e22e>category</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>keyof</span> <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>IssueCategory</span>,
    <span style=color:#a6e22e>msg</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>,
) {
    <span style=color:#66d9ef>const</span> {<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>} <span style=color:#f92672>=</span> <span style=color:#a6e22e>node</span>;
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>nodeMark</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>id</span>;
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>issueInfo</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>category</span><span style=color:#e6db74>}</span><span style=color:#e6db74>-</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>msg</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;

    <span style=color:#75715e>// 因为这两种节点每次的id并不是固定的，所以用区域来标识节点
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 会存在误判，不过可以接受，因为区域变化说明设计稿有改动，那这一块的校验内容也要变化，可以理解为产生了新的问题
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>/@AI/</span>.<span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>id</span>)) {
        <span style=color:#a6e22e>nodeMark</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>x</span><span style=color:#e6db74>}</span><span style=color:#e6db74>-</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>y</span><span style=color:#e6db74>}</span><span style=color:#e6db74>-</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>width</span><span style=color:#e6db74>}</span><span style=color:#e6db74>-</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>height</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
    }

    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>md5</span>(<span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>nodeMark</span><span style=color:#e6db74>}</span><span style=color:#e6db74>-</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>issueInfo</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
}
</code></pre></div><h2 id=规则下架>规则下架</h2><p>如果某个规则上线后有严重的问题，可能导致每次检视都有很多误报，所以需要有个规则下架的机制。这个实现也很简单：</p><ul><li>「规范检测库」对外提供接口获取所有规则名，管理员可以对这些规则进行下架操作</li><li>任务队列中执行规范检测时，获取被下架的规则传入「规范检测库」，在注册规则之前将这些下架规则忽略即可。</li></ul><p><img src=https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/%E8%A7%84%E5%88%99%E4%B8%8B%E6%9E%B6.png alt=规则下架></p><h1 id=碎语>碎语</h1><p>这个工具包含了插件开发、服务端开发、规范检测库的实现、UI 平台开发，一个人独立开发了两个月时间，工作量大时间紧。我将它拆分为三个迭代，每个拆分的小迭代都顺利的按时完成。经过演示、内测、宣贯，设计团队在这个月开始使用了。和高频使用的设计师进行沟通时，得到的都是提质提效的肯定反馈，还是很欣慰的。</p><h4>Comments:</h4><div id=cusdis_thread data-host=https://cusdis.com data-app-id=a2f9224a-c294-4108-998e-c8818b5dec9e data-page-id=4692b3ef1f4871cfa1e1d836acb29807 data-page-url=https://cocacolf.github.io/blog/%E8%AE%BE%E8%AE%A1%E7%A8%BF%E8%A7%84%E8%8C%83%E6%A3%80%E8%A7%86%E5%B7%A5%E5%85%B7/ data-page-title=开发了设计稿规范检视工具></div><script async defer src=https://cusdis.com/js/cusdis.es.js></script><footer><script src=//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/tex.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/javascript.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/js.min.js></script><script>hljs.configure({languages:[]});hljs.initHighlightingOnLoad();</script><hr><div class=copyright>© CocaColf | <a href=https://github.com/CocaColf>Github</a></div></footer></article></body></html>