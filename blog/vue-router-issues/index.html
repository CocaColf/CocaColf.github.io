<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.78.1"><title>vue-router重复点击报错和新链接跳转失败 - CocaColf</title><meta name=description content="最近解决了项目的前端路由问题，具体而言有两个：
 路由重复点击，会在控制台输出报错 一个 vue-router 渲染出来的 a 标签，右键新链接打开，在新页面无法打开网页  由于我们公司内外网隔离，所以无法具体截图现象。
路由重复点击，会在控制台输出报错 报错的大概内容为： vueAll.js?v=3.0:2 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: xxxx。
阅读 vue-router 的文档，可以看到：
 router.push 或 router.replace 将返回一个 Promise
 查看 vue-router 源码，从源码此处可以看出，我们对此方法进行异常处理，便可一劳永逸解决此问题。
因此在初始化路由时，对此方法进行处理：
import VueRouter from 'vue-router'; function handleRouterErr (methodsList) { methodsList.forEach(item => { const ORIGIN_METHOD = VueRouter.prototype[item]; VueRouter.prototype[item] = function (location) { let vm = this; return ORIGIN_METHOD.call(vm, location).catch(err => err); } }); } // 调用 handleRouterErr(['push', 'replace']) 无法在新标签页打开链接 右键一个 vue-router 渲染的 a 标签，新标签页打开后页面显示 Not Found。"><link rel="shortcut icon" href=favicon.ico><link rel=stylesheet href=/css/ui.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway"></head><body><header class="container no-print"><div class=u-header><nav class=bar><ul><li><a href=/><img class=icon-text src=/img/prev.svg></a></li><li><a href=/about>关于</a></li><li><a href=/readings>我读</a></li><li><a href=/tags>标签</a></li><li><a href=/tags/beyond-programming/>编程之外</a></li><li><a href=/tags/programming/>编程相关</a></li></ul></nav></div></header><main class=container><article><header><hgroup id=brand><h1>vue-router重复点击报错和新链接跳转失败</h1><h5><time datetime="2021-01-14 00:00:00 +0000 UTC">Jan 14, 2021</time>
<span class=no-print>-
<a href=/tags/%e6%8a%80%e6%9c%af>技术</a>
<a href=/tags/programming>programming</a>
<span></h5></hgroup><hr class=sep></header><p>最近解决了项目的前端路由问题，具体而言有两个：</p><ul><li>路由重复点击，会在控制台输出报错</li><li>一个 vue-router 渲染出来的 a 标签，右键新链接打开，在新页面无法打开网页</li></ul><p>由于我们公司内外网隔离，所以无法具体截图现象。</p><h2 id=路由重复点击会在控制台输出报错>路由重复点击，会在控制台输出报错</h2><p>报错的大概内容为： <code>vueAll.js?v=3.0:2 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: xxxx</code>。</p><p>阅读 vue-router 的文档，可以<a href=https://router.vuejs.org/zh/guide/essentials/navigation.html#router-push-location-oncomplete-onabort>看到</a>：</p><blockquote><p>router.push 或 router.replace 将返回一个 Promise</p></blockquote><p>查看 vue-router 源码，从源码此处可以看出，我们对此方法进行异常处理，便可一劳永逸解决此问题。</p><p><img src=https://i.loli.net/2021/01/14/IveygjmtX4xpC9W.png alt=vue-router-push.png></p><p>因此在初始化路由时，对此方法进行处理：</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kr>import</span> <span class=nx>VueRouter</span> <span class=nx>from</span> <span class=s1>&#39;vue-router&#39;</span><span class=p>;</span>

<span class=kd>function</span> <span class=nx>handleRouterErr</span> <span class=p>(</span><span class=nx>methodsList</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>methodsList</span><span class=p>.</span><span class=nx>forEach</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=kr>const</span> <span class=nx>ORIGIN_METHOD</span> <span class=o>=</span> <span class=nx>VueRouter</span><span class=p>.</span><span class=nx>prototype</span><span class=p>[</span><span class=nx>item</span><span class=p>];</span>

        <span class=nx>VueRouter</span><span class=p>.</span><span class=nx>prototype</span><span class=p>[</span><span class=nx>item</span><span class=p>]</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>location</span><span class=p>)</span> <span class=p>{</span>
            <span class=kd>let</span> <span class=nx>vm</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
            <span class=k>return</span> <span class=nx>ORIGIN_METHOD</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>vm</span><span class=p>,</span> <span class=nx>location</span><span class=p>).</span><span class=k>catch</span><span class=p>(</span><span class=nx>err</span> <span class=p>=&gt;</span> <span class=nx>err</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>});</span>
<span class=p>}</span>

<span class=c1>// 调用
</span><span class=c1></span><span class=nx>handleRouterErr</span><span class=p>([</span><span class=s1>&#39;push&#39;</span><span class=p>,</span> <span class=s1>&#39;replace&#39;</span><span class=p>])</span>
</code></pre></div><h2 id=无法在新标签页打开链接>无法在新标签页打开链接</h2><p>右键一个 <code>vue-router</code> 渲染的 <code>a</code> 标签，新标签页打开后页面显示 <code>Not Found</code>。</p><p><strong>base配置不正确</strong></p><p>首先，我发现我们所有的页面都是 <code>ip/index#xxxx</code> 的形式，但是此时打开的链接确是 <code>ui/#/#/xxxx</code> 的形式。也就是说渲染出来的a标签的href是不正确的。因此很容易想到我们路由配置有问题。</p><p>路由是这样写的：</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=nx>router</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>VueRouter</span><span class=p>({</span>
    <span class=nx>routes</span><span class=o>:</span> <span class=nx>ROUTER_DATA</span><span class=p>,</span>
    <span class=nx>base</span><span class=o>:</span> <span class=s1>&#39;/ui/#&#39;</span>
<span class=p>});</span>
</code></pre></div><p>那显然这个 base 是不对的，期望最后渲染的href应当是 <code>index#xxx</code> 的形式，所以这里应该将base改成 <code>/index/</code>。</p><p>为什么这里不需要 # 符号了？因为查看 <code>vue-router</code> 代码可以看到，构造 href 逻辑如下：</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kd>function</span> <span class=nx>createHref</span> <span class=p>(</span><span class=nx>base</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>fullPath</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>mode</span><span class=p>)</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>path</span> <span class=o>=</span> <span class=nx>mode</span> <span class=o>===</span> <span class=s1>&#39;hash&#39;</span> <span class=o>?</span> <span class=s1>&#39;#&#39;</span> <span class=o>+</span> <span class=nx>fullPath</span> <span class=o>:</span> <span class=nx>fullPath</span>
  <span class=k>return</span> <span class=nx>base</span> <span class=o>?</span> <span class=nx>cleanPath</span><span class=p>(</span><span class=nx>base</span> <span class=o>+</span> <span class=s1>&#39;/&#39;</span> <span class=o>+</span> <span class=nx>path</span><span class=p>)</span> <span class=o>:</span> <span class=nx>path</span>
<span class=p>}</span>
</code></pre></div><p>mode 默认为 hash，所以会自动添加 # 号，这也解释了为何新标签页的那个链接存在两个 #。</p><p>我们的服务器上并没有 ui 这个目录，所以自然返回 404。</p><p><strong>新标签页打开报错</strong></p><p>当修改完base后，这次新标签页打开的链接似乎正常了：<code>ip/index/#/xxxx</code>，但是打开页面白屏，控制台报错了：<code>uncaught syntaxerror unexpected token '&lt;'</code>。</p><p>仔细一看，发现此时链接其实还是不正确的，相比于正确的链接，在index后面多了一个 /。为何多了这个会导致报错？</p><p>我选择一个报错的js文件请求，从请求中可以看到两个问题：</p><ul><li>请求的js文件链接不正确。正常情况下，这个js的请求应该是： <code>/static/xxx.js</code>，但是此时却是 <code>/index/static/xxx.js</code></li><li><code>Content-Type</code> 不正确，此时是 <code>text/html</code>，返回的也是一个html文件</li></ul><p>寻其根本，还是第一个请求不正确的问题导致的。</p><p>这些报错文件我看了一下，是在 webpack 打包后的 index.html 中引入的，在这个 html 文件中，都是以相对路径 <code>./static/xxx</code> 引入的。于是我想这里应该改成绝对路径，于是我将webpack配置中的 <code>relativePublicPath</code> 设置为 <code>true</code>，重新生成打包文件后，问题就解决了。</p><h2 id=更简单的解决方式>更简单的解决方式</h2><p>我上面的解决方式改了三个地方：</p><ul><li>修改 base</li><li>修改入口文件资源路径</li><li>修改 webpack relativePublicPath 配置</li></ul><p>组长觉得应该不需要这样改，他搜索了 base 相关信息，发现大家都不配置 base，于是和我说删掉 base 这个配置试试。我一试，还真就解决新标签页跳转问题了。</p><p>那么为什么这种修改方式是可以的？</p><p>首先还是回到链接身上观察一下，在不修改 base 的情况下：</p><ul><li>正确的链接是 <code>ip/index#xxxx</code></li><li>有问题的链接是 <code>ip/ui/#/#/xxxx</code></li></ul><p>然后再来看 vue-router 构造 href 的规则：</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kd>function</span> <span class=nx>createHref</span> <span class=p>(</span><span class=nx>base</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>fullPath</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>mode</span><span class=p>)</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>path</span> <span class=o>=</span> <span class=nx>mode</span> <span class=o>===</span> <span class=s1>&#39;hash&#39;</span> <span class=o>?</span> <span class=s1>&#39;#&#39;</span> <span class=o>+</span> <span class=nx>fullPath</span> <span class=o>:</span> <span class=nx>fullPath</span>
  <span class=k>return</span> <span class=nx>base</span> <span class=o>?</span> <span class=nx>cleanPath</span><span class=p>(</span><span class=nx>base</span> <span class=o>+</span> <span class=s1>&#39;/&#39;</span> <span class=o>+</span> <span class=nx>path</span><span class=p>)</span> <span class=o>:</span> <span class=nx>path</span>
<span class=p>}</span>
</code></pre></div><p>我们项目的 base 配置是 <code>/ui/#</code>，mode 默认为 hash ，fullPath 是 router-link 中设置的 to 参数，那么此时 path 就是 <code>#/{fullPath}</code>，我们配置了 base，那么最终结果就是 <code>/ui/#/#/{fullPath}</code>。路由链接发生了改变，浏览器会重新请求资源，但是服务器上并没有 /ui/ 这个文件导致无法返回正确的页面。</p><p>此时我们把base删去，那么整个 createHref 的结果就是 <code>#/{fullPath}</code>。我们改变的仅仅只是 hash 部分，hash 部分并不会被包括在 http 请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变 hash 不会重新加载页面，也就是此时此链接点击时，浏览器跳转的实际地址为 <code>ip/index#{fullPath}</code>，和我们希望的链接形式是一致的。</p><p>删除一行代码就解决了。</p><p>那么这种改法是偶然还是通用？</p><p>之所以说是不是偶然，因为整个过程看起来似乎是刚好拼成了我们期望的链接形式。对于这个问题，我们需要看看 base 到底是什么。</p><p>文档上写的是：</p><blockquote><p>应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 &ldquo;/app/&rdquo;</p></blockquote><p>举个例子：</p><p>假设单页应用的入口文件地址是：<code>www.xxx.com/test/index.html</code>，那么 base 应当是 <code>/test/index.html</code>。
如果后端服务在 /test/ 下，那么后端配置 Nginx 配置，将 /test/ 重定向到 /test/index.html，那么我们的 base 此时就是写 /test/。</p><p>实际项目：</p><p>在我们的项目中，我们访问项目时，整个过程是 <code>ip -> ip/index</code>，从请求中可以看到发送了一个 <code>ip/index</code> 的网络请求，这个请求指向一个 cgi 文件，最终返回了 index.html 文件，那么此时前端代码或者说得更小一点就是 vue-router 开始工作了，渲染出正确的组件。</p><p>那么回到最开始的问题：这种改法是偶然还是通用？</p><p>答案是通用的。因为我们配置了项目的根路径重定向到 /index，所以这里我们的 base 应该是配置 / ，但是vue-router默认 base 为 /，所以我们可以删去。这么一品，反而也有一些偶然的味道了。</p></article><nav class="no-print post-nav"><a class=prev-post href=https://cocacolf.github.io/blog/%E7%AE%80%E5%8D%95%E7%89%88html%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/><img class=icon-text src=/img/prev.svg>简单版html模板引擎</a>
<a class=next-post href=https://cocacolf.github.io/blog/2020/>2020<img class=icon-text src=/img/next.svg></a></nav><section id=related><h4>See Also</h4><ul><li><a href=/blog/%E7%AE%80%E5%8D%95%E7%89%88html%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/>简单版html模板引擎</a></li><li><a href=/blog/node.js-event-loop/>Node.js Event Loop</a></li><li><a href=/blog/%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/>什么才算是真正的编程能力</a></li></ul></section><script src=https://utteranc.es/client.js repo issue-term=url label theme=github-light crossorigin=anonymous async></script><div id=disqus_thread class=no-print></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><hr class=sep></main><footer class="container no-print"><div class=u-footer><a href=mailto:CocaColf@gmail.com><img class=icon-social src=/img/email.svg alt="Email Me!"></a>
<a href=https://github.com/CocaColf><img class=icon-social src=/img/github.svg alt=Github></a>
<a href=https://cocacolf.github.io/index.xml target=_blank><img class=icon-social src=/img/feed.svg alt=Feed></a><p>&copy; 2020 CocaColf</p><a href=#brand><img class=icon-text src=/img/toup.svg alt="To Up">
<span>Back to Up</span></a></div></footer></body></html>