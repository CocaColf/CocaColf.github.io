<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>vue-router重复点击报错和新链接跳转失败 - CocaColf</title><meta property="og:title" content="vue-router重复点击报错和新链接跳转失败 - CocaColf"><meta name=twitter:card content="summary"><meta property="description" content="最近解决了项目的前端路由问题，具体而言有两个：
[&amp;hellip;] 由于我们公司内外网隔离，所以无法具体截图现象。
[&amp;hellip;] 报错的大概内容为： vueAll.js?v=3.0:2 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: xxxx。 &amp;hellip;"><meta property="og:description" content="最近解决了项目的前端路由问题，具体而言有两个：
[&amp;hellip;] 由于我们公司内外网隔离，所以无法具体截图现象。
[&amp;hellip;] 报错的大概内容为： vueAll.js?v=3.0:2 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: xxxx。 &amp;hellip;"><meta name=twitter:image content="https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/vue_router_src.png"><link href=//cdn.bootcss.com/highlight.js/9.12.0/styles/monokai.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body class=blog><header class=masthead><h1><a href=/>CocaColf</a></h1><p class=tagline>庭前桃李满，院外小径芳</p><nav class=menu><input id=menu-check type=checkbox hidden>
<label id=menu-label for=menu-check class=unselectable hidden><span class="icon close-icon">✕</span>
<span class="icon open-icon">☰</span>
<span class=text>Menu</span></label><ul><li><a href=/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/tags/>Tags</a></li><li><a href=/index.xml>Subscribe</a></li></ul></nav></header><article class=main><header class=title><h1>vue-router重复点击报错和新链接跳转失败</h1><h3>2021-01-14</h3><hr></header><p>最近解决了项目的前端路由问题，具体而言有两个：</p><ul><li>路由重复点击，会在控制台输出报错</li><li>一个 vue-router 渲染出来的 a 标签，右键新链接打开，在新页面无法打开网页</li></ul><p>由于我们公司内外网隔离，所以无法具体截图现象。</p><h2 id=路由重复点击会在控制台输出报错>路由重复点击，会在控制台输出报错</h2><p>报错的大概内容为： <code>vueAll.js?v=3.0:2 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: xxxx</code>。</p><p>阅读 vue-router 的文档，可以<a href=https://router.vuejs.org/zh/guide/essentials/navigation.html#router-push-location-oncomplete-onabort>看到</a>：</p><blockquote><p>router.push 或 router.replace 将返回一个 Promise</p></blockquote><p>查看 vue-router 源码，从源码此处可以看出，我们对此方法进行异常处理，便可一劳永逸解决此问题。</p><p><img src=https://blog-1305900062.cos.ap-guangzhou.myqcloud.com/blog_pic/vue_router_src.png alt=vue-router-push.png></p><p>因此在初始化路由时，对此方法进行处理：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>VueRouter</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;vue-router&#39;</span>;

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleRouterErr</span> (<span style=color:#a6e22e>methodsList</span>) {
    <span style=color:#a6e22e>methodsList</span>.<span style=color:#a6e22e>forEach</span>(<span style=color:#a6e22e>item</span> =&gt; {
        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ORIGIN_METHOD</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>VueRouter</span>.<span style=color:#a6e22e>prototype</span>[<span style=color:#a6e22e>item</span>];

        <span style=color:#a6e22e>VueRouter</span>.<span style=color:#a6e22e>prototype</span>[<span style=color:#a6e22e>item</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>location</span>) {
            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>vm</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ORIGIN_METHOD</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>vm</span>, <span style=color:#a6e22e>location</span>).<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#a6e22e>err</span>);
        }
    });
}

<span style=color:#75715e>// 调用
</span><span style=color:#75715e></span><span style=color:#a6e22e>handleRouterErr</span>([<span style=color:#e6db74>&#39;push&#39;</span>, <span style=color:#e6db74>&#39;replace&#39;</span>])
</code></pre></div><h2 id=无法在新标签页打开链接>无法在新标签页打开链接</h2><p>右键一个 <code>vue-router</code> 渲染的 <code>a</code> 标签，新标签页打开后页面显示 <code>Not Found</code>。</p><p><strong>base配置不正确</strong></p><p>首先，我发现我们所有的页面都是 <code>ip/index#xxxx</code> 的形式，但是此时打开的链接确是 <code>ui/#/#/xxxx</code> 的形式。也就是说渲染出来的a标签的href是不正确的。因此很容易想到我们路由配置有问题。</p><p>路由是这样写的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>router</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>VueRouter</span>({
    <span style=color:#a6e22e>routes</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>ROUTER_DATA</span>,
    <span style=color:#a6e22e>base</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;/ui/#&#39;</span>
});
</code></pre></div><p>那显然这个 base 是不对的，期望最后渲染的href应当是 <code>index#xxx</code> 的形式，所以这里应该将base改成 <code>/index/</code>。</p><p>为什么这里不需要 # 符号了？因为查看 <code>vue-router</code> 代码可以看到，构造 href 逻辑如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createHref</span> (<span style=color:#a6e22e>base</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>, <span style=color:#a6e22e>fullPath</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>, <span style=color:#a6e22e>mode</span>) {
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>path</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mode</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;hash&#39;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>fullPath</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>fullPath</span>
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>base</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>cleanPath</span>(<span style=color:#a6e22e>base</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;/&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>path</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>path</span>
}
</code></pre></div><p>mode 默认为 hash，所以会自动添加 # 号，这也解释了为何新标签页的那个链接存在两个 #。</p><p>我们的服务器上并没有 ui 这个目录，所以自然返回 404。</p><p><strong>新标签页打开报错</strong></p><p>当修改完base后，这次新标签页打开的链接似乎正常了：<code>ip/index/#/xxxx</code>，但是打开页面白屏，控制台报错了：<code>uncaught syntaxerror unexpected token '&lt;'</code>。</p><p>仔细一看，发现此时链接其实还是不正确的，相比于正确的链接，在index后面多了一个 /。为何多了这个会导致报错？</p><p>我选择一个报错的js文件请求，从请求中可以看到两个问题：</p><ul><li>请求的js文件链接不正确。正常情况下，这个js的请求应该是： <code>/static/xxx.js</code>，但是此时却是 <code>/index/static/xxx.js</code></li><li><code>Content-Type</code> 不正确，此时是 <code>text/html</code>，返回的也是一个html文件</li></ul><p>寻其根本，还是第一个请求不正确的问题导致的。</p><p>这些报错文件我看了一下，是在 webpack 打包后的 index.html 中引入的，在这个 html 文件中，都是以相对路径 <code>./static/xxx</code> 引入的。于是我想这里应该改成绝对路径，于是我将webpack配置中的 <code>relativePublicPath</code> 设置为 <code>true</code>，重新生成打包文件后，问题就解决了。</p><h2 id=更简单的解决方式>更简单的解决方式</h2><p>我上面的解决方式改了三个地方：</p><ul><li>修改 base</li><li>修改入口文件资源路径</li><li>修改 webpack relativePublicPath 配置</li></ul><p>组长觉得应该不需要这样改，他搜索了 base 相关信息，发现大家都不配置 base，于是和我说删掉 base 这个配置试试。我一试，还真就解决新标签页跳转问题了。</p><p>那么为什么这种修改方式是可以的？</p><p>首先还是回到链接身上观察一下，在不修改 base 的情况下：</p><ul><li>正确的链接是 <code>ip/index#xxxx</code></li><li>有问题的链接是 <code>ip/ui/#/#/xxxx</code></li></ul><p>然后再来看 vue-router 构造 href 的规则：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createHref</span> (<span style=color:#a6e22e>base</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>, <span style=color:#a6e22e>fullPath</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>, <span style=color:#a6e22e>mode</span>) {
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>path</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mode</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;hash&#39;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>fullPath</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>fullPath</span>
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>base</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>cleanPath</span>(<span style=color:#a6e22e>base</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;/&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>path</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>path</span>
}
</code></pre></div><p>我们项目的 base 配置是 <code>/ui/#</code>，mode 默认为 hash ，fullPath 是 router-link 中设置的 to 参数，那么此时 path 就是 <code>#/{fullPath}</code>，我们配置了 base，那么最终结果就是 <code>/ui/#/#/{fullPath}</code>。路由链接发生了改变，浏览器会重新请求资源，但是服务器上并没有 /ui/ 这个文件导致无法返回正确的页面。</p><p>此时我们把base删去，那么整个 createHref 的结果就是 <code>#/{fullPath}</code>。我们改变的仅仅只是 hash 部分，hash 部分并不会被包括在 http 请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变 hash 不会重新加载页面，也就是此时此链接点击时，浏览器跳转的实际地址为 <code>ip/index#{fullPath}</code>，和我们希望的链接形式是一致的。</p><p>删除一行代码就解决了。</p><p>那么这种改法是偶然还是通用？</p><p>之所以说是不是偶然，因为整个过程看起来似乎是刚好拼成了我们期望的链接形式。对于这个问题，我们需要看看 base 到底是什么。</p><p>文档上写的是：</p><blockquote><p>应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 &ldquo;/app/&rdquo;</p></blockquote><p>举个例子：</p><p>假设单页应用的入口文件地址是：<code>www.xxx.com/test/index.html</code>，那么 base 应当是 <code>/test/index.html</code>。
如果后端服务在 /test/ 下，那么后端配置 Nginx 配置，将 /test/ 重定向到 /test/index.html，那么我们的 base 此时就是写 /test/。</p><p>实际项目：</p><p>在我们的项目中，我们访问项目时，整个过程是 <code>ip -> ip/index</code>，从请求中可以看到发送了一个 <code>ip/index</code> 的网络请求，这个请求指向一个 cgi 文件，最终返回了 index.html 文件，那么此时前端代码或者说得更小一点就是 vue-router 开始工作了，渲染出正确的组件。</p><p>那么回到最开始的问题：这种改法是偶然还是通用？</p><p>答案是通用的。因为我们配置了项目的根路径重定向到 /index，所以这里我们的 base 应该是配置 / ，但是vue-router默认 base 为 /，所以我们可以删去。这么一品，反而也有一些偶然的味道了。</p><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script><script src=//unpkg.com/valine/dist/Valine.min.js></script><script type=text/javascript>new Valine({el:'#vcomments',appId:'5wCdX2LaFPlapBWb5D7PwjeL-gzGzoHsz',appKey:'TbOwzyyIqoN2h62jdFwidX0L',notify:'false',verify:'false',avatar:'robohash',placeholder:'说点什么吧...',visitor:'true'});</script><footer><script src=//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/tex.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/javascript.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/languages/js.min.js></script><script>hljs.configure({languages:[]});hljs.initHighlightingOnLoad();</script><hr><div class=copyright>© CocaColf | <a href=https://github.com/CocaColf>Github</a></div></footer></article></body></html>